services:
  tesseract-api:
    build:
      context: ..
      dockerfile: docker/Dockerfile.pi  # Use Pi-optimized Dockerfile
      target: production
    container_name: tesseract-api-test-${USER:-testuser}  # Unique name per user
    ports:
      - "${TEST_PORT:-3000}:3000"  # Configurable port to avoid conflicts
    environment:
      - NODE_ENV=production
      - PORT=3000
    volumes:
      # User-space Tesseract language data (no system pollution)
      - ../testing/docker-data/tesseract-data:/usr/share/tesseract-ocr/4.00/tessdata/
      # User-space temp directory with proper ownership
      - ../testing/docker-data/tmp:/tmp/tesseract-api:Z
    restart: "no"  # Don't auto-restart on shared machine
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/ocr/status"]
      interval: 60s  # Less frequent on shared machine
      timeout: 10s
      retries: 2
      start_period: 60s
    # Conservative resource limits for shared machine
    deploy:
      resources:
        limits:
          memory: 768M  # Reduced for shared environment
          cpus: '1.5'   # Reduced for shared environment
        reservations:
          memory: 256M  # Lower reservation
          cpus: '0.5'
    # Logging configuration (user-space)
    logging:
      driver: "json-file"
      options:
        max-size: "5m"   # Smaller logs on shared machine
        max-file: "2"
    # Labels for easy cleanup
    labels:
      - "project=tesseract-api-test"
      - "user=${USER:-testuser}"
      - "environment=testing"

# No named volumes - use bind mounts to user directory instead
# This prevents system-wide volume pollution